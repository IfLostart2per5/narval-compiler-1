unit:io: => {
  private byte Integer :: BUILTIN_CONST_NEWLINE << 0xA; // Caractere de nova linha

  public auto _ :: label:lenof:(auto Text :: string) => {
    asm:([
      "lenof_prologue:",
      "PUSH(BASE_POINTER)", // salva o valor do base pointer
      "MOV(BASE_POINTER, STACK_POINTER)", // configura o novo base pointer
      "SUB(STACK_POINTER, 4)", // aloca espaço na stack se necessário

      "builtin_lenof_contar_caracteres:",
      "MOV(SOURCE_INDEX, [BASE_POINTER+8])", // carrega o endereço da string do argumento
      "CMP(byte [SOURCE_INDEX], 0)", // verifica se o caractere atual é nulo
      "JE builtin_lenof_fim_contagem", // se for nulo, pula para o fim da contagem
      "INC(SOURCE_INDEX)", // incrementa 1 em SOURCE_INDEX, ou seja, move para o próximo caractere
      "JMP builtin_lenof_contar_caracteres", // repete o loop

      "builtin_lenof_fim_contagem:",
      "SUB(SOURCE_INDEX, [BASE_POINTER+8])", // calcula o comprimento da string (SOURCE_INDEX - endereço inicial)
      
      "lenof_epilogue:",
      "MOV(STACK_POINTER, BASE_POINTER)", // restaura o valor original da stack pointer
      "POP(BASE_POINTER)", // restaura o valor original do base pointer
      "RETURN", // retorna
    ]);
  }

  public auto _ :: label:print:(auto Text :: string) => {
    asm:([
      "print_prologue:",
      "PUSH(BASE_POINTER)", // salva o valor do base pointer
      "MOV(BASE_POINTER, STACK_POINTER)", // configura o novo base pointer
      "SUB(STACK_POINTER, 4)", // aloca espaço na stack se necessário

      "MOV(SOURCE_INDEX, [BASE_POINTER+8])", // carrega o endereço da string do argumento
      "CALL lenof", // chama a função lenof
      
      "MOV(SYSTEM_CALL, SYS_WRITE)", // syscall de sys_write
      "MOV(ARG_1, STD_OUT)", // std_out
      "MOV(ARG_2, [BASE_POINTER+8])", // carrega a string para printar
      "MOV(ARG_3, SOURCE_INDEX)", // SOURCE_INDEX contém o tamanho da string
      "INSTRUCTION", // chama o kernel e executa o código

      "print_epilogue:",
      "MOV(STACK_POINTER, BASE_POINTER)", // restaura o valor original da stack pointer
      "POP(BASE_POINTER)", // restaura o valor original do base pointer
      "RETURN", // retorna
    ]);
  }

  public auto _ :: label:println:(auto Text :: string) => {
    asm:([
      "print_prologue:",
      "PUSH(BASE_POINTER)", // salva o valor do base pointer
      "MOV(BASE_POINTER, STACK_POINTER)", // configura o novo base pointer
      "SUB(STACK_POINTER, 4)", // aloca espaço na stack se necessário

      "MOV(SOURCE_INDEX, [BASE_POINTER+8])", // carrega o endereço da string do argumento
      "CALL lenof", // chama a função lenof
      
      "MOV(SYSTEM_CALL, SYS_WRITE)", // syscall de sys_write
      "MOV(ARG_1, STD_OUT)", // std_out
      "MOV(ARG_2, [BASE_POINTER+8])", // carrega a string para printar
      "MOV(ARG_3, SOURCE_INDEX)", // SOURCE_INDEX contém o tamanho da string
      "INSTRUCTION", // chama o kernel e executa o código

      "MOV(SYSTEM_CALL, SYS_WRITE)", // syscall de sys_write
      "MOV(ARG_1, STD_OUT)", // std_out
      "MOV(ARG_2, BUILTIN_CONST_NEWLINE)", // carrega a string para printar
      "MOV(ARG_3, 1)", // SOURCE_INDEX contém o tamanho da string
      "INSTRUCTION", // chama o kernel e executa o código

      "print_epilogue:",
      "MOV(STACK_POINTER, BASE_POINTER)", // restaura o valor original da stack pointer
      "POP(BASE_POINTER)", // restaura o valor original do base pointer
      "RETURN", // retorna     
    ]);
  }
}

export:([io]);
