unit:io:{
  private byte Integer :: BUILTIN_CONST_NEWLINE << 0xA; // Caractere de nova linha

  public auto Text :: label:lenof:(auto Text :: string) => {
    asm:([
      "contar_caracteres:",
      "\tcmp byte [esi], 0", // verifica se o caractere atual é nulo
      "\tje fim_contagem", // se for nulo, pula para o fim da contagem
      "\tinc esi", // incrementa 1 em esi, ou seja, move para o próximo caractere,
      "\tjmp contar_caracteres", // repete o loop

      "fim_contagem:",
      "\tsub esi, {{string:() == 3? }}", // calcula o comprimento da string (ESI - endereço inicial)
      "\tret"
      // Agora, ESI contém o comprimento da string
    ]) 
  }

  public auto _ :: label:print:(auto _ :: string) => {
    asm:([
      "\tmov esi, {{string}}", // carrega o endereço da string em ESI
      "\tcall lenof", // chama a função lenof
      
      "\tmov eax, 4", // syscall de sys_write
      "\tmov ebx, 1", // std_out
      "\tmov ecx, {{string}}", // carrega a string para printar
      "\tmov edx, esi", // ESI contém o tamanho da string
      "\tint 0x80" // chama o kernel e executa o código.
    ])
  }

  public auto _ :: label:println:(auto _ :: string) => {
    asm:([
      "\tmov esi, {{string}}", // carrega o endereço da string em ESI
      "\tcall lenof", // chama a função lenof
      
      "\tmov eax, 4", // syscall de sys_write
      "\tmov ebx, 1", // std_out
      "\tmov ecx, {{string}}", // carrega a string para printar
      "\tmov edx, esi", // ESI contém o tamanho da string
      "\tint 0x80", // chama o kernel e executa o código.

      "\tmov eax, 4", // syscall de sys_write
      "\tmov ebx, 1", // std_out
      "\tmov ecx, BUILTIN_CONST_NEWLINE", // caractere de nova linha
      "\tmov edx, 1", // tamanho do caractere de nova linha
      "\tint 0x80" // chama o kernel e executa o código.
    ])
  }

  public auto Text :: label:input:(byte Text :: input_text) => {

  }
}

export:([io]);
